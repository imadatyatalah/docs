---
title: 'Referential actions'
metaTitle: 'Referential actions'
metaDescription: 'Referential actions let you define the update and delete behavior of related models on the database level'
tocDepth: 2
preview: true
---

<TopBlock>

As of [2.26.0](https://github.com/prisma/prisma/releases/tag/2.26.0] Prisma now supports _referential actions_ as a Preview feature part of the Prisma Schema Language.

This is a [**preview feature**](../../../about/releases#preview) and can be accessed by:

1. [Upgrading to version v2.26.0 of Prisma](../../../guides/upgrade-guides/upgrading-to-latest).
2. Adding `referentialActions` to the `previewFeatures` field of the Prisma Client [`generator`](../../../reference/api-reference/prisma-schema-reference#generator) block in the `prisma.schema` file.

```prisma file=schema.prisma
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["referentialActions"]
}
```

After enabling the preview feature flag you now have 3 options:

1. Make your schema reflect the current state of the database by running [Introspection](../introspection). Afterwards you can see the referential actions of all relations your relations explicitly, which might be different than the new defaults.
2. Define custom referential actions on your data model relation fields. You then update the database schema by using [Prisma Migrate](../prisma-migrate) or the [`db push`](../prisma-migrate/db-push) command.
3. Apply the new default referential actions, that exist when no custom actions are added manually, by using [Prisma Migrate](../prisma-migrate), or [`db push`](../prisma-migrate/db-push), without making any changes to your existing Prisma schema.

To begin using referential actions you add them to the `@relation` attribute in your schema.

```prisma
@relation(fields: [authorId], references: [id], onDelete: Cascade)
```

See [Upgrade guides](#upgrade-guides) for more information on adopting the feature in your project.

</TopBlock>

## What are referential actions?

Referential actions are constraints that can be used to define how a referenced record is handled by the database when either an [`update`](../prisma-client/crud#update) or [`delete`](../prisma-client/crud#delete) query is run.

These include:

- [`Cascade`](#cascade)
- [`Restrict`](#restrict)
- [`NoAction`](#noaction)
- [`SetNull`](#setnull)
- [`SetDefault`](#setdefault)

To understand how referential actions can impact your data it is important to understand how foreign key constraints work.

[Foreign keys](../../../guides/general-guides/database-workflows/foreign-keys#overview) are used to link fields between tables and represent [relations](./relations) in your database.

The following example shows `User` and `Post` models with a [one-to-many](./relations#one-to-many-relations) relationship. The `Post` model has an `authorId` field which is mapped to a foreign key constraint on the database table.

```prisma file=schema.prisma
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

The foreign key ensures that when saving rows into the `Post` table, any value in the `authorId` [scalar field](./data-model#scalar-fields) must be referencing an existing value in the `id` column of the `User` table. 

When a [migration](../prisma-migrate) is run the following SQL is produced:

```sql
CREATE TABLE "Post" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "title" TEXT NOT NULL,
    "authorId" INTEGER NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT
);
```

And the foreign key relation that was created can be seen here:

```sql
FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
```

### Behavior without the preview feature flag `referentialActions`

Prisma creates foreign keys for each relation between data models, with the following defaults: 

- `ON DELETE CASCADE` - The users posts are deleted when the user is deleted.
- `ON UPDATE CASCADE` - When a users `id` is updated, the corresponding `authorId` on the `Posts` table is updated too.

When invoking the [`delete()`](../../../guides/database/advanced-database-tasks/cascading-deletes/postgresql#91-validating-restrict) or [`deleteAll()`](../prisma-client/crud#delete-all-records) methods using the Prisma Client, a runtime check is performed and the deletion of records prevented if they are referencing related objects. **This prevents cascade behavior**. 

If you need to actually use the cascade behavior configured in the database, you _can_ use [`$raw`](../prisma-client/raw-database-access) SQL queries to [delete multiple referenced records](../prisma-client/crud#deleting-all-data-with-raw-sql--truncate) (such as users blog posts) and the deletion will be successful. This is because the Prisma Client will **not** perform runtime checks on raw queries.

### Behavior after `2.26.0` with the preview feature flag `referentialActions`

With the feature flag **enabled**, the default value of `ON DELETE` is [`Restrict`](#restrict) (`ON DELETE RESTRICT`).

The Prisma Client will **not** perform any runtime checks before deleting related records with `delete()` or `deleteAll()`. This means the deletion will succeed or fail according to the underlying foreign key relations and any referential actions set. 

By default the deletion will be prevented by the database because of the **new** default action, [`Restrict`](#restrict) (`ON DELETE RESTRICT`). To make it succeed you will need to manually add the [`Cascade`](#cascade) action. 

#### Required relations

| Clause      |  < 2.26.0       | 2.26.0 +   |
| :---------- | :-------------- | :--------- |
| `onDelete`  | `Cascade`       | `Restrict` |
| `onUpdate`  | `Cascade`       | `Cascade`  |

#### Optional relations

| Clause      |  < 2.26.0       | 2.26.0 +   |
| :---------- | :-------------- | :--------- |
| `onDelete`  | `SetNull`       | `SetNull`  |
| `onUpdate`  | `Cascade`       | `Cascade`  |

<Admonition type="warning">

Referential actions are **not currently** supported on [implicit many-many relations](./relations#implicit-vs-explicit-many-to-many-relations), instead you must create a [join table](./relations#how-to-use-a-relation-table-with-a-many-to-many-relationship) in your schema file and explicitly set the referential actions on the many-many relation.

</Admonition>

## Types of referential actions

### Cascade

When used with `onDelete`, The `Cascade` action deletes all records that are dependant on the record being deleted. 

When used with `onUpdate`, it updates the relation scalar filed if the referenced scalar fields of the dependant record are updated.

#### Example usage

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    authorId  Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

<Admonition type="info">

`onUpdate` defaults to `Cascade` when not set. This applies to both **optional** and **required** relations. `onDelete` defaults to `Cascade` on **required** relations.

</Admonition>

##### Result of using `Cascade`?

If a `User` record is deleted then their posts are deleted too. If a users id is updated then the corresponding `authorId` is also updated

### Restrict

The `Restrict` action will prevent the update or deletion of any parent records which have connected children and throw an error. 

> **Note**: The children records can still be deleted

#### Example usage

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  author    User    @relation(fields: [authorId], references: [id])
  author    User    @relation(fields: [authorId], references: [id], onDelete: Restrict)
  authorId  Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `Restrict`?

If a `User` has a related post in the `Post` table you will **not** be able to delete the `User`, you will be able to delete (all) the posts however.

<Admonition type="warning">

The `Restrict` action is not is **not** available on [SQL Server](../../database-connectors/microsoft-sql-server) and will trigger a schema validation error. Instead, use the equivalent [`NoAction`](#noaction).

</Admonition>

### NoAction

The `NoAction` action is similar to `Restrict` in that it will prevent the update or deletion of any records which are connected and throw an error. The difference between the two is dependant on the database being used. But in general they both have the same functionality. In Postgres however, `NoAction` defers the check until later in the transaction.

#### Example usage

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  author    User    @relation(fields: [authorId], references: [id])
  author    User    @relation(fields: [authorId], references: [id], onDelete: NoAction)
  authorId  Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `NoAction`?

If a `User` has a related post in the `Post` table you will **not** be able to delete them. This will result in a runtime error.

### SetNull

The `SetNull` action will set relation [scalar fields](./data-model#scalar-fields) to null if the relation is updated or deleted. If one or more of the relations scalar fields are required a runtime error will be thrown.

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: SetNull)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `SetNull`?

If a `User` is deleted then the corresponding `authorId` field in the `Post` table will be set to `Null`

### SetDefault

The `SetDefault` action will set relation [scalar fields](./data-model#scalar-fields) to their default values upon updated or deletion of a related record. If no defaults are provided for any of the scalar fields, a runtime error will be thrown.

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: SetDefault)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `SetDefault`?

If a `User` is deleted then the corresponding `authorId` field in the `Post` table will be set to its default value.


## Upgrade guides

The following lists a number of ways to upgrade depending on your scenario.

1. Upgrading Prisma to 2.26.0 _**without**_ adding the feature flag.

  As the preview feature is opt in, you should notice **no** difference to your database, its constraints or how it handles relations.

2. Upgrading Prisma to 2.26.0 and _**enabling**_ the feature flag **without** adding custom referential actions. (Using the **new** defaults)

  If you want to keep your current database constraints but upgrade you can enable the feature flag. To do so you must have a required relation in your schema, then run either a Prisma Migration or `db push`, this will change the default for `ON DELETE` from `CASCADE` TO `RESTRICT`.

  The change is relevant for both the Prisma Client _and_ Migration. If an attempt is made to delete a referenced object, if their are related records, a database error will be thrown.

3. Upgrading Prisma to 2.26.0, _**enabling**_ the feature flag and **adding custom referential actions**.

  Once you have upgraded the Prisma version and added the feature flag to the generator block you can begin using the referential actions.

  ### Using Introspection

  You can begin by running an [Introspection](../introspection) on your database. This will update your data modals to use `ON DELETE CASCADE` and explicitly set `onDelete: Cascade` on your modals `@relation` fields. 

  The happens because the the old defaults (`ON DELETE CASCADE`) are different from the new (`ON DELETE RESTRICT`), so when the introspection is run, it will see the old default and use that to explicitly set the referential action on the relation.

  Once the introspection has run and the referential action has been set, you can change the `Post` author relation to `onDelete: SetNull`.

  ### Using Migration

  You can begin by running a [Migration](../prisma-migrate) (or `db push`) on your database. This will change the default referential actions from `ON DELETE CASCADE` to `ON DELETE RESTRICT`. 
  
  Next you can manually add a custom referential action to the `User` relation on the `Profile` modal by adding the following line after the `references` property; `onDelete: Cascade`. 
  
  Finally you can change the `Post` author relation to `onDelete: SetNull`.

  ```prisma file=schema.prisma
  model Profile {
    user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId Int     @unique
  }

  model Post {
    author    User?     @relation(fields: [authorId], references: [id], onDelete: SetNull)
    authorId  Int?
  }
  ```

  If you then choose to delete a `User`, their corresponding `Profile` records will be deleted and the `authorId` scalar field on the `Post` table will be set to null.

## Important caveats

If you are using the [Introspection](../introspection) workflow it's important to be aware of how the changes to the default referential actions and their subsequent behaviors could potentially affect your data. 

When you run an Introspection the [old](#current-behavior) default referential actions in the database will be reflected in the Prisma schema (See [Using Introspection](#using-introspection)). 

This means that if you are calling the [`delete()`](../../../guides/database/advanced-database-tasks/cascading-deletes/postgresql#91-validating-restrict) or [`deleteAll()`](../prisma-client/crud#delete-all-records) methods on any required relations, cascade deletions will **not** be triggered as the Prisma Clients default implementation has changed to [`Restrict`](#restrict).
