---
title: 'Referential actions'
metaTitle: 'Referential actions'
metaDescription: 'Referential actions let you define the update and delete behavior of related models on the database level'
tocDepth: 2
preview: true
---

<TopBlock>

As of **2.26.0** Prisma now supports referential actions as part of the Prisma Schema Language.

This is a [**preview feature**](../../../about/releases#preview) and can be accessed by:

1. [Upgrading to version v2.26.0 of Prisma](../../../guides/upgrade-guides/upgrading-to-latest).
2. Adding `referentialActions` to the `previewFeatures` field of the [`generator`](../../../reference/api-reference/prisma-schema-reference#generator) block in the `prisma.schema` file.

```prisma file=schema.prisma
generator client {
    provider = "prisma-client-js"
    previewFeatures: ['referentialActions']
}
```

You now have 3 options:

1. Make your schema reflect the current state of the database by running an [Introspection](../introspection). You can now opt in and use the new referential actions if you wish.
2. Define custom referential actions on your data model relation fields. You then update the database schema by running a [Migration](../prisma-migrate) or the [`db push`](../prisma-migrate/db-push) command.
3. Use the new default referential actions that exist when no custom actions are added manually by running a [Migration](../prisma-migrate).

To begin using referential actions you add them to the `@relation` attribute in your schema.

```prisma
@relation(fields: [authorId], references: [id], onDelete: Restrict)
```

</TopBlock>

## What are referential actions?

Referential actions are constraints that can be used to define how a referenced record is handled by the database when either an [`update`](../prisma-client/crud#update) or [`delete`](../prisma-client/crud#delete) query is run.

These include:

- [`Cascade`](#cascade)
- [`Restrict`](#restrict)
- [`NoAction`](#noaction)
- [`SetNull`](#setnull)
- [`SetDefault`](#setdefault)

To understand how referential actions can impact your data it is important to understand how foreign key constraints work.

[Foreign keys](../../../guides/general-guides/database-workflows/foreign-keys#overview) are used to link fields between tables and represent [relations](./relations) in your database.

The following example shows `User` and `Post` models with a [one-to-many](./relations#one-to-many-relations) relationship. The `Post` model has an `authorId` field which is mapped to a foreign key constraint on the database table.

```prisma file=schema.prisma
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

The foreign key ensures that when saving rows into the `Post` table, any value in the `authorId` [scalar field](./data-model#scalar-fields) must be referencing an existing value in the `id` column of the `User` table. 

When a [migration](../prisma-migrate) is run the following SQL is produced:

```sql
CREATE TABLE "Post" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "title" TEXT NOT NULL,
    "authorId" INTEGER NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT
);
```

And the foreign key relation that was created can be seen here:

```sql
FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE CASCADE ON UPDATE CASCADE
```

### Current behavior 

Prisma creates foreign keys for each relation between data models, with the following defaults: 

- `ON DELETE CASCADE` - The users posts are deleted when the user is deleted.
- `ON UPDATE CASCADE` - When a users `id` is updated, the corresponding `authorId` on the `Posts` table is updated too.

When invoking the [`delete()`](../../../guides/database/advanced-database-tasks/cascading-deletes/postgresql#91-validating-restrict) or [`deleteAll()`](../prisma-client/crud#delete-all-records) methods using the Prisma Client, a runtime check is performed and the deletion of records prevented if they are referencing related objects. **This prevents cascade behavior**. 

If you need to replicate the cascade behavior, you _can_ use [`$raw`](../prisma-client/raw-database-access) SQL queries to [delete multiple referenced records](../prisma-client/crud#deleting-all-data-with-raw-sql--truncate) (such as users blog posts) and the deletion will be successful, this is because the Prisma Client will **not** perform runtime checks.

### New behavior

With the feature flag **enabled**, the default value of `ON DELETE` is [`Restrict`](#restrict) (`ON DELETE RESTRICT`).

The Prisma Client will **not** perform any runtime checks before deleting related records with `delete()` or `deleteAll()`. This means the deletion will succeed or fail according to the underlying foreign key relations and any referential actions set. 

By default the deletion will be prevented by the database because of the **new** default action, [`Restrict`](#restrict) (`ON DELETE RESTRICT`). To make it succeed you will need to manually add the [`Cascade`](#cascade) action. 

#### Required relations

| Clause      |  < 2.26.0       | 2.26.0 +   |
| :---------- | :-------------- | :--------- |
| `onDelete`  | `Cascade`       | `Restrict` |
| `onUpdate`  | `Cascade`       | `Cascade`  |

#### Optional relations

| Clause      |  < 2.26.0       | 2.26.0 +   |
| :---------- | :-------------- | :--------- |
| `onDelete`  | `SetNull`       | `SetNull`  |
| `onUpdate`  | `Cascade`       | `Cascade`  |

<Admonition type="warning">

Referential actions are **not currently** supported on [implicit many-many relations](./relations#implicit-vs-explicit-many-to-many-relations), instead you must create a [join table](./relations#how-to-use-a-relation-table-with-a-many-to-many-relationship) in your schema file and explicitly set the referential actions on the many-many relation.

</Admonition>

## Types of referential actions

### Cascade

When used with `onDelete`, The `Cascade` action deletes a record if a dependant record is deleted. 

When used with `onUpdate`, it updates the relation scalar filed if the referenced scalar fields of the dependant record are updated.

#### Example usage

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

<Admonition type="info">

`onUpdate` defaults to `Cascade` when not set. This applies to both **optional** and **required** relations. `onDelete` defaults to `Cascade` on **required** relations.

</Admonition>

##### Result of using `Cascade`?

If a `User` record is deleted then their posts are deleted too. If a users id is updated then the corresponding `authorId` is also updated

<Admonition type="warning">

The `Cascade` action prevents both update and deletion operations from completing if any records are connected

</Admonition>

### Restrict

The `Restrict` action will prevent the update or deletion of any records which are connected. 

#### Example usage

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: Restrict)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `Restrict`?

If a `User` has a related post in the `Post` table you will **not** be able to delete them. This will result in a runtime error.

<Admonition type="warning">

The `Restrict` action is not is **not** available on [SQL Server](../../database-connectors/microsoft-sql-server) and will trigger a schema validation error. Instead, use the equivalent [`NoAction`](#noaction).

</Admonition>

### NoAction

The `NoAction` action is similar to `Restrict` in that it will prevent the update or deletion of any records which are connected and throw an error. The difference between the two is dependant on the database being used. But in general they both have the same functionality. In Postgres however, `NoAction` defers the check until later in the transaction.

#### Example usage

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: NoAction)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `NoAction`?

If a `User` has a related post in the `Post` table you will **not** be able to delete them. This will result in a runtime error.

### SetNull

The `SetNull` action will set relation [scalar fields](./data-model#scalar-fields) to null if the relation is updated or deleted. If one or more of the relations scalar fields are required a runtime error will be thrown.

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: SetNull)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `SetNull`?

If a `User` is deleted then the corresponding `authorId` field in the `Post` table will be set to `Null`

### SetDefault

The `SetDefault` action will set relation [scalar fields](./data-model#scalar-fields) to their default values upon updated or deletion of a related record. If no defaults are provided for any of the scalar fields, a runtime error will be thrown.

```prisma file=schema.prisma highlight=5;add|4;delete
model Post {
    id        Int     @id @default(autoincrement())
    title     String
    author    User    @relation(fields: [authorId], references: [id])
    author    User    @relation(fields: [authorId], references: [id], onDelete: SetDefault)
    authorId  Int
}

model User {
  id    Int         @id @default(autoincrement())
  posts Post[]
}
```

##### Result of using `SetDefault`?

If a `User` is deleted then the corresponding `authorId` field in the `Post` table will be set to its default value.


## Upgrade guides

The following lists a number of ways to upgrade depending on your scenario.

1. Upgrading Prisma to 2.26.0 _**without**_ adding the feature flag.

As the preview feature is opt in, you should notice **no** difference to your database, its constraints or how it handles relations.

2. Upgrading Prisma to 2.26.0 and _**enabling**_ the feature flag without adding custom referential actions. (Using the **new** defaults)

If you want to keep your current database constraints but upgrade you can enable the feature flag. To do so you must have a required relation in your schema, then run either a Prisma Migration or `db push`, this will change the default for `ON DELETE` from `CASCADE` TO `RESTRICT`.

The change is relevant for both the Prisma Client _and_ Migration. If an attempt is made to delete a referenced object, if their are related records, a database error will be thrown.

3. Upgrading Prisma to 2.26.0, _**enabling**_ the feature flag and **adding custom referential actions**.

You can begin using the new referential actions by first upgrading to version 2.26.0 of Prisma and then changing your schema to use the new clauses and actions. 

An example might be changing the default behavior of `Profile` modals `User` relation to `ON DELETE CASCADE`  and setting the `Post` author relation to `ON DELETE SET NULL`

```prisma file=schema.prisma
model Profile {
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int     @unique
}

model Post {
  author    User?     @relation(fields: [authorId], references: [id], onDelete: SetNull)
  authorId  Int?
}
```

You must then run a migration (or `db push`) for the new referential actions to take affect. 

If you then choose to delete a `User`, their corresponding `Profile` records will be deleted and the `authorId` scalar field on the `Post` table will be set to null.

4. Upgrading Prisma to 2.26.0 and _**enabling**_ the feature flag _**without**_ running Prisma Migrate or `db push`

TODO...